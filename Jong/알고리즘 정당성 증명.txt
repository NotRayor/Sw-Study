알고리즘을 달달 외우는 것이 알고리즘에 대한 깨달음을 완전히 흡수했다고 보기는 어렵다.
증명을 이해하는 편이 사용하는 입장에서도, 더 큰 공부가 된다.!

많은 증명을 직접 따라해봐야한다...

정당성 증명에 나타나는 패턴 몇가지,

1. 수학적 귀납법,
ex.
100개의 도미노가 순서대로 놓여있는 상황,

사실 2가지,
첫번째 도미노를 손으로 밀어 넘어트린다.
한 도미노가 쓰러지면, 다음 도미노도 반드시 쓰러진다.

단계나누기, 증명하고 싶은 사실을 여러단계로 나눈다.
	도미노에선, 100개를 각각 하나씩으로 나눈다.

첫단계 증명,첫단계에서, 증명하고 싶은 내용이 성립함을 보인다. 
	첫번째 도미노가 넘어짐을 증명,

귀납 증명, 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도
	성립함을 보인다.
	한도미노가 쓰러지면 반드시 다음 도미노가 쓰러진다... 

ex2. 사다리,
사다리 게임은 언제나 1:1 대응이 된다. 왜?

단계나누기, 사다리에 수평의 줄을 그어 서로를 연결시키는 것을 하나의 단계로 구분한다.

첫단계 증명, 텅빈 N개의 가로줄은 맨위와 맨 아래 선택지가 1:1 대응이 된다.

귀납 증명, 수평을 그었을 때, 위 아래 선택지의 결과가 서로 교차되어 1:1 대응이 된다..
	한획을 그을때마다, 두 세로줄의 결과가 뒤바뀐다.


1-2. 반복문 불변식,
대부분 알고리즘은 반복적인 요소를 가지고 있기 때문에, 유용하다.
귀납법은 이런 알고리즘들이 옳은 답을 계산함을 보이기 위해서 
알고리즘 각 단계가 정답에 이르는 길 위에 있음을 보이고, 결과적으로는
알고리즘이 옳음을 증명하는데,

귀납법을 이용한 증명이 바로 반복문 불변식이다..
반복문 불변식 - 내용이 한번 실행될때마다, 중간결과가 우리가 원하는 답으로
	가는 길 위에 잘 있는지 명시하는 조건,
	반복문이 마지막 정답을 정확히 계산하기 위해서는,
	항상 이 식이 변하지 않고 성립해야한다.

step1. 반복문 진입시에 불변식이 성립함을 보인다.
step2. 반복문 내용이 불변식을 깨트리지 않음을 보인다.
step3. 반복문 종료시, 불변식 성립하면, 항상 우리가 정답을 구했음을 보인다.

step1,2 가 증명된다면, 반복문 종료할때까지 항상 이 불변식이 성립한다고 볼 수 있다.

코드에 적용할때는, 초기조건, 유지조건으로 구분해서 판단한다.

ex. 이진탐색,
이진 탐색의 경우, 배열 A는 오름차순으로 정렬되어있다고 가정한다.
원하는 결과 A[i-1] < x <= A[i] 인 i를 반환, 
A[-1] 음무한, A[n]을 무한으로 둔다. 그래야 그 사이에 무조건 x 값이 있으니까

반복문 불변식 1 , lo < hi, lo값은 항상 hi값보다 작아야한다.
반복문 불변식 2, A[lo] < x <= A[hi] 가 항상 성립해야한다.

초기조건
while문이 시작할 때, lo와 hi는 초기값 -1과 n으로 초기화된 상태다,
만약 n = 0이여도, while문을 완전히 건너뛰기 때문에 ( 즉, lo값, hi값 변화가 없다 ) 
, 불변식 1 은 항상 성립한다.
A[-1] = 음의 무한, A[n] = 양의 무한 이므로, 불변식2도 성립한다. x는 무조건 그 사이에 있으니까!

유지조건, while문 내부가 불변식을 깨뜨리지 않음을 보인다.
while의 조건은 lo + 1 < hi로, lo와 hi가 2이상의 차이가 있음을 나타낸다.
그러므로 mid는 항상 그 사이에 위치한다고 볼 수 있고,
2가지의 경우, 
첫번째로, A[mid] < x 인 경우, x <= A[hi]가 성립함을 이미 알기에,
A[mid] < x < A[hi] 이므로 lo에 mid를 삽입해도 불변식이 성립한다
두번째로, x <= A[mid] 인 경우, 이미 A[lo] < x 가 성립함을 알고 있어서,
A[lo] < x <= A[mid]임을 알 수 있고, 그러므로 high에 mid를 대입해도 불변식2는 성립한다.

이 과정을 통해서, 반복문이 끝난 후에는, 원하는 값 x가 A[hi]에 대입될 것임을 알 수 있다.


삽입 정렬과 반복문 불변식,
삽입 정렬은 각 원소를 순서대로 고려하며, 이 원소를 앞에 있는 정렬된 부분 수열에 끼워넣는 작업을
반복하는 알고리즘이다.

불변식 a : A[0... i-1]는 이미 정렬되어있다 // 결과적으로 이걸 증명하려면?
불변식 b : A[j+1 ... i]의 모든 원소는, 원소 A[j]보다 크다.
불변식 c : A[0...i] 구간은 A[j]를 제외하고 정렬되어있다.

불변식을 생각해내는 것이 생각만큼 쉽지가 않다...

초기조건,
반복문이 시작될 때, i = 0이면, 해당 구간은 비어있으니 불변식 a가 항상 성립된다.

유지,
for문이 종료할 때, 이 불변식이 유지됨을 보이기 위해 while문의 정당성을 증명해야한다.

====
while문..
초기조건, while문 진입시, A[j+1...i]는 빈구간이므로, 불변식 b는 참,
	불변식(a)에 의해, A[0...i-1]이 정렬되어 있으니, while문 진입시, 불변식 c도 참,

유지조건, while반복 된다면, A[j-1] > A[j]여서 들어온 것, swap으로 서로를 교체하면
	A[j-1] < A[j]가 되고 j를 1 줄이면.. 불변식b는 참,
	A[j]와 이전 원소를 교환해도, 그 외의 다른 원소들의 상대적 순서는 안 변하니까,
	불변식 c도 참,
이 증명을 통해, while문이 항상 A[0...i]를 정렬된 상태로 남겨둔다는 것을 보여준다.
이것은 불변식a의 유지조건에 해당되므로, 삽입 정렬은 확실히 배열을 정렬한다.


단정문을 통해, 반복문 불변식을 강제해서, 불변식이 깨질 경우, 프로그램이
강제 종료되도록 만들 수도 있다. 단.. 성능을 많이 잡아먹을 것


3. 귀류법 , 
평소보다 많은 인원이 표를 예매해버렸다. 처음에는 자리가 남아있지만,
앞으로 지나칠 역에서 승객들이 더 탑승하며 열차가 미어터질 것이 자명한 상황..
각 승객이 어느 역에서 승차해 어느 역에서 하차할지 모두 알고 있을 때,
열차에서 쫒겨나는 수를 최소화하려면, 누구를 쫓아내는 게 좋을까?
쫒겨나는 수를 최소화하려면, 오랫동안 탑승하고 있는.. 탑승해서 가장 먼거리에서
내리는 승객들을 우선적으로 쫓아내면 된다.
이건 직관적으로 알겠는데, 논리적으로 왜 먼거리에 내리는 승객들을 우선적으로 쫓아내야할까?

가장 좋은 방법 중 하나는, 먼거리에 내리는 승객 대신, 다른 승객을 내쫓았다고 가정하고 생각해보면 
된다. 짧은 거리에 내리는 청년과, 먼거리에 내리는 할아버지가 있다고 가정했을 때,
청년을 태운다면, 청년이 금방 내림으로써 그 자리에 다른 승객이 탑승하게 된다.
하지만, 할아버지를 태운다면, 계속 그 자리에 앉아있어 다른 승객들이 탑승하지 못하게 되는 것,
즉, 청년을 쫓아낼때, 이득인 상황이 없다.
이렇듯, 우리가 원하는 바와 반대의 상황을 가정하고 논리를 전개해 결론이 잘못됐음을
찾아내는 증명 기법이 귀류법이다.
귀류법은 최선임을 증명할 때, 많이 이용된다.우리가 선택한 답보다 좋은 답이 있다고 
가정한 이후에, 사실은 그런일이 없다는 것을 증명하면, 우리가 최선의 답을 선택했음을
보이니까...

ex. 책상쌓기,
상자 형태의 책상을 여러개 쌓아올리자, 무거운 것부터 가벼운 것,
책 꽂아도 부숴질 비실비실한 것과 코끼리가 올라가도 꿈쩍하지 않는 튼튼 한 것까지
다양한 책상이 있다.
각 책장마다 버틸수 있는 최대 무게와 자신의 무게가 주어진다고 볼때,
책장을 가장 높이 쌓는다면, 몇 개나 쌓을 수 있을까?
above(i)가 i번 책장 위에 쌓인 모든 책장의 집합이라 할때,
책장 위에 올라간  다른 책장들의 무게의 합이 견딜 수 있는 최대 무게를 초과해서는 안된다..

이 경우, 첫번째로 책장을 쌓는 순서를 결정해야한다.
가장 높이 책장을 쌓을 때, 책장들이 항상 어떤 순서를 가짐을 보인다.
항상 가장 무거운 책장을 아래쪽에 쌓는 것이 좋을 것. 
무게 별로, 정렬해서 가장 무거운 책장 일수록 아래로 놓을 것인가
아니면 버틸 수 있는 튼튼한 책상 별로 정렬해 튼튼한 책상을 아래에 놓을 것인가..
결과는 자신 무게합 + 최대 무게가 큰 것을 아래에 놓아야한다.

이것을 증명하기 위해 귀류법을 쓰자.
귀류법을 쓰기 위해서는 우리가 증명하려는 사실의 반대를 가정해야한다.
W+M가 더 큰 책장 A가 더 작은 책상 B의 위에 있다고 보면 우리 생각의 반대인셈,
이때 A와 B의 위치를 항상 바꿀 수 있음을 증명해보자. 그럼
M + W가 큰 것이 밑에 가도록 책상을 쌓아도 최선의 답을 얻을 수 있는 증거가 된다.
결과적으로, Ma > X + Wb가 되었고,
A도 나머지 상자 + b상자 무게를 지탱할 수 있음이 증명되었으며,
이로 인해 우리가 원했던 순서로 쌓았을 때, 가장 높은 탑을 얻지 못하는 경우가
존재하지 않는다고 알 수 있다.


귀류법을 이용한 증명들,
알고리즘에서, 귀류법 + 귀납법을 이용한 증명을 자주볼 수 있다.
알고리즘 결과가 최선(최단 경로, 가장 높은 탑 등)임을 보이기 위해,
각 단계에서 최선의 선택을 했음을 귀류법으로 증명하고 
각 단계에서 최선의 선택을 한다면, 다음 단계에서도 최선의 선택을 할 수 있음을
귀납법을 통해 증명하는 것이다.

=======
그 외의, 다른 증명 기술들...

1. 비둘기 집의 원리,
10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면,
2마리 이상의 비둘기가 들어간 집이 반드시 하나는 있기 마련이다.

혹은, 머리숱이 적을수록 세금을 적게 부과하는 탈모자 위로법안이 통과되어,
서울의 모든 시민이 자신의 머리카락을 세서 세금 면제 세류를 제출했을때,
같은 머리카락 갯수를 가진 사람이 존재할 것인가?
>> 통상적으로 인간은 10만 가닥의 머리털이 있다.
그런데 서울시민이 1천만명임으로, 10만가지의 비둘기 집에 천만마리의 비둘기가 모두 들어간셈이니,
머리카락이 동일한 사람이 반드시 2명 이상 있을 것..

2. 동전 뒤집기,
100개의 동전이 바닥에 깔려있다. 이 중 F개는 앞면, 100 - F개는 뒷면이 위로 놓여있다고 한다.
이 동전들이 모두 앞면을 향하게 뒤집고 싶은데, 한번 뒤집을 때 반드시 X개의 동전을 한꺼번에
뒤집어야한다. 같은 동전 2번 이상 뒤집는 것도 노 상관, 이때 뒤집는 횟수를 최소화하고 싶을때,
답의 상한은? 상한! ( 뒤집는 수를 최소환 상태에서 가장 많이 뒤집은 경우는? )
100,

3. 순환 소수 찾기,
실수 연산을 쓰지 않고 분수 a/b를 소수형태로 출력한다 가정했을 때,
순환소수의 경우에는 무한루프가 돌게 된다. 그러므로 순환소수는 별도로 처리해야하는데,
이 소수가 무한소수.. 그러니까 순환소수임을 어떻게 알까?
while문,
cout << a/b; 
a = (a % b) * 10;
일때, a%b의 범위는 0 ~ b-1이다.
while문이 b+1횟수만큼 종료되지 않고 반복했다면,
a % b의 결과는 b가지의 결과만 가질 수 있으니, 결과가 중복된 것이다.
고로 같은 결과가 첫번째로 등장하고.. 이후 두번째 등장할때까지가 무한히 순환되는
소수임을 알 수 있다.

4. 구성적 증명,
다른 증명 기법들과는 다른 관점으로 접근하는 증명방법,
구성적 증명은 흔히 우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해 사용된다.

답이 존재한다는 사실을 논증하는 것이, 우리가 지금까지 다룬 방식들이라면
구성적 증명은 답의 실제 예를 들거나, 답을 만드는 방법을 실제로 제시하는 증명,
( 앞의 방식 사실 논증 , 구성적 증명, 실제 예를 들거나, 답을 만드는 방법을 제시 )

ex. 하늘을 나는 교통수단을 만들 수 있다는 주장을 증명한다면?
비구성적 증명은 양력의 법칙에서부터 시작해 지구의 공기밀도, 등을 하나하나 열거하며
가정하에 교통수단이 하늘을 날 수 있음을 보이려 한다.

반대로 구성적 증명이 하는 일은 비행기를 만들어 보여주거나, 비행기 만드는 설명서를 건네주는 것..
'답이 존재하는 가'에 대한 답변으로 '이렇게 만들면 된다'라 하는 것이 구성적 증명이므로,
구성적 증명의 내용은 사실상 알고리즘인 경우가 많다.

4-1. 안정적 결혼 문제,
n명의 남성과 여성이 단체 미팅에서 만났습니다. 여러 게임을 진행하는 동안
모든 사람은 자신이 원하는 상대방의 우선순위를 맘 속에 정했고, 이제 시간이 되어
남자 1호와 여자1호, 남자 2호와 여자 2호가 각각 짝이 되었다.
그런데 남1 여2는, 자신들의 짝보다 서로를 더 선호한다.
이런 일이 일어나지 않도록 짝을 지어줄 수 있을까? 혹은 불가능한 경우가 있을까?

대표적인 구성적 증명의 예제이다.
이 문제를 푼 사람들은 답의 존재성 대신, 답을 만드는 알고리즘을 제시했다.

1) 처음에는 여성들이 모두 자신이 선호하는 남성의 앞에 가서, 프로포즈를 합니다.
남성이 그중 제일 마음에 드는 여성을 고르면, 나머지는 퇴짜를 맞고 제 자리

2) 퇴짜 맞은 여성들은, 다음으로 맘에드는 남자들에게 가 프로포즈,
	현재 자기짝보다 맘에드는 여성이라면, 지금 파트너에 퇴짜 후 새여성한테 간다.
3) 더 프로포즈할 여성이 없을 때까지 반복한다.. 

이 알고리즘이 원하는 답을 찾기 위해,
알고리즘이 항상 종료한다고 가정하고,
모든 사람이 짝을 찾으며, 결과적으로 이뤄지는 짝들이 항상 안정적임을 증명해야한다.

종료 증명, 각 여성은 퇴짜맞을 때마다, 지금까지 프로포즈한 남성들보다 우선순위가
낮은 남성에게 프로포즈한다. 따라서 각 여성이 최대 n명의 남성들에게
순서대로 프로포즈하고 나면, 더이상 프로포즈할 남성이 없으므로 이 과정은 언젠가 종료된다.

모든사람이 짝을 찾는지 증명, 프로포즈를 받은 남성은 반드시 한명을 선택해야하고,
더 우선순위 높은 여성이 프로포즈 해야 짝을 바꾼다. 그래서 프로포즈를 받은 남성은
항상 짝이 있다.
귀류법을 적용하여, 남녀 한사람씩 짝을 찾지 못하고 남았다고 가정해도,
여성은 우선순위가 높은 순서대로 모두에게 한번씩 프로포즈, 이 남성에게도
한번은 프로포즈를 했을 것... 이 남성은 프로포즈를 받아들였어야하고,
따라서 짝을 찾지 못하는 사람은 없다..








